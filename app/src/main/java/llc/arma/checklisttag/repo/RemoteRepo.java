package llc.arma.checklisttag.repo;import android.util.Log;import androidx.lifecycle.LiveData;import androidx.lifecycle.MutableLiveData;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.JsonParseException;import org.jetbrains.annotations.NotNull;import java.io.IOException;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import java.util.concurrent.TimeUnit;import java.util.function.Consumer;import java.util.function.Function;import javax.inject.Inject;import llc.arma.checklisttag.App;import llc.arma.checklisttag.SharedHelper;import llc.arma.checklisttag.Utils;import llc.arma.checklisttag.data.ObjectSourceToWebMapper;import llc.arma.checklisttag.data.ObjectWebToSourceMapper;import llc.arma.checklisttag.data.Tag;import llc.arma.checklisttag.data.UserWebToSourceMapper;import llc.arma.checklisttag.db.entity.ObjectEntity;import llc.arma.checklisttag.db.model.Smart;import llc.arma.checklisttag.net.AuthApi;import llc.arma.checklisttag.net.AuthRequest;import llc.arma.checklisttag.net.SyncApi;import llc.arma.checklisttag.net.WebObject;import llc.arma.checklisttag.net.WebUser;import okhttp3.Cookie;import okhttp3.CookieJar;import okhttp3.HttpUrl;import okhttp3.OkHttpClient;import okhttp3.Request;import retrofit2.Response;import retrofit2.Retrofit;import retrofit2.converter.gson.GsonConverterFactory;public class RemoteRepo {    private final ObjectSourceToWebMapper objectSourceToWebMapper = new ObjectSourceToWebMapper();    private final UserWebToSourceMapper userWebToSourceMapper = new UserWebToSourceMapper();    private final ObjectWebToSourceMapper objectWebToSourceMapper = new ObjectWebToSourceMapper();    private final PromiseFuture<retrofit2.Response<WebUser>> promiseFuture = new PromiseFuture<>();    public boolean send(Tag tag){        try {            Response<Void> response = getSyncApi().sendObject(objectSourceToWebMapper.map(tag.getObject())).execute();            return response.isSuccessful();        } catch (IOException e) {            e.printStackTrace();        }        return false;    }    @NotNull    public LiveData<Boolean> loadTag(){        MutableLiveData<Boolean> result = new MutableLiveData<>();        Executors.newSingleThreadExecutor().execute(() -> {            try {                Response<List<WebObject>> response = getSyncApi().getTreeData().execute();                if(response.body() != null && response.isSuccessful()) {                    App.getAppComponent().provideLocalRepo().deleteSyncedMarks();                    List<ObjectEntity> list = objectWebToSourceMapper.map(response.body());                    for (ObjectEntity smartObject : list) {                        smartObject.setSync(0);                        App.getAppComponent().provideLocalRepo().insert(new Smart(smartObject));                    }                    result.postValue(true);                }else {                    result.postValue(false);                }            } catch (IOException e) {                e.printStackTrace();            }catch (JsonParseException e){                result.postValue(false);            }        });        return result;    }    public WebUser login(String login, String password)            throws WrongAuthDataException, TimeoutException {        try {            Response<WebUser> response = getAuthApi().auth(new AuthRequest(login, password,                    Utils.getAndroidId())).execute();            if(response.isSuccessful() && response.body() != null){                return response.body();            }else {                throw new WrongAuthDataException();            }        } catch (IOException e) {            throw new TimeoutException();        }    }    public AuthApi getAuthApi(){        return buildRetrofit(buildAuthClient(),                getGsonConverterFactory()).create(AuthApi.class);    }    public SyncApi getSyncApi(){        return buildRetrofit(buildSyncClient(getAuthApi()), getGsonConverterFactory()).create(SyncApi.class);    }    private GsonConverterFactory getGsonConverterFactory(){        Gson gson = new GsonBuilder()                .setLenient()                .create();        return GsonConverterFactory.create(gson);    }    private Retrofit buildRetrofit(OkHttpClient okHttpClient,                                   GsonConverterFactory factory){        return new Retrofit.Builder()                .baseUrl("http://127.0.0.1")                .addConverterFactory(factory)                .client(okHttpClient)                .build();    }    private OkHttpClient buildAuthClient(){        return new OkHttpClient.Builder()                .cookieJar(new SessionCookieJar())                .readTimeout(30, TimeUnit.SECONDS)                .connectTimeout(30, TimeUnit.SECONDS)                .addInterceptor(chain -> {                    Request originRequest = chain.request();                    HttpUrl httpUrl = originRequest.url();                    String[] split =  httpUrl.url().toString().split("127.0.0.1", 2);                    String path = SharedHelper.getServerAddress() + split[1];                    return chain.proceed(originRequest.newBuilder().url(path).build());                })                .build();    }    private OkHttpClient buildSyncClient(AuthApi authApi) {        return new OkHttpClient.Builder()                .readTimeout(30, TimeUnit.SECONDS)                .connectTimeout(30, TimeUnit.SECONDS)                .cookieJar(new SessionCookieJar())                .addInterceptor(chain -> {                    Request originRequest = chain.request();                    HttpUrl httpUrl = originRequest.url();                    String[] split =  httpUrl.url().toString().split("127.0.0.1", 2);                    String path = SharedHelper.getServerAddress() + split[1];                    return chain.proceed(originRequest.newBuilder().url(path).build());                })                .addInterceptor(chain -> {                    Request originRequest = chain.request();                    Request authRequest = originRequest.newBuilder().addHeader("Authorization", "Bearer " + SharedHelper.getUser().getToken()).build();                    okhttp3.Response response = chain.proceed(authRequest);                    if (response.code() == 401) {                        Response<WebUser> t = null;                        try {                            t = promiseFuture.ttt(() ->  authApi.refresh().execute()).get();                        } catch (ExecutionException | InterruptedException e) {                            e.printStackTrace();                        }                        if(t.body() != null) {                               SharedHelper.setUser(new UserWebToSourceMapper().map(t.body()));                               authRequest = originRequest.newBuilder().addHeader("Authorization", "Bearer " + t.body().getToken()).build();                               response.close();                               response = chain.proceed(authRequest);                           }                    }                    return response;                }).build();    }    static class SessionCookieJar implements CookieJar {        @Override        public void saveFromResponse(HttpUrl url, @NotNull List<Cookie> cookies) {            if (url.encodedPath().endsWith("login") || url.encodedPath().endsWith("refresh")) {                SharedHelper.saveCookies(cookies);            }        }        @Override        public @NotNull List<Cookie> loadForRequest(HttpUrl url) {            List<Cookie> cookies = SharedHelper.getCookies();            if (!url.encodedPath().endsWith("login") && cookies != null) {                return cookies;            }            return Collections.emptyList();        }    }    public static class TimeoutException extends Exception {}    public static class InvalidTokenException extends Exception {}    public static class WrongAuthDataException extends Exception {}    static class PromiseFuture<T> {        private final ExecutorService es = Executors.newFixedThreadPool(8);        private Future<T> tttt = null;        public PromiseFuture() {        }        public Future<T> ttt(Callable<T> cb) throws ExecutionException, InterruptedException {            if (tttt == null) {                tttt = es.submit(() -> {                    try {                        T o = cb.call();                        tttt = null;                        return o;                    } catch (Exception e) {                        e.printStackTrace();                        tttt = null;                        return null;                    }                });            }            return tttt;        }    }}